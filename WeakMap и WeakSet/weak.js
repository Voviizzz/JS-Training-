// Объект WeakMap — коллекция пар ключ-значение. В качестве ключей могут быть использованы только объекты, а значения могут быть произвольных типов.
// Синтаксис

// new WeakMap([iterable])

// Параметры

// iterable

//     Может быть массивом или любым другим итерируемым объектом, элементы которого являются парами ключ-значение (массивы из двух элементов). Каждая пара ключ-значение будет добавлена во вновь созданный экземпляр WeakMap. Null обрабатывается как undefined.

// Описание

// Ключами WeakMap могут быть только объекты. Примитивы в качестве ключей не допускаются (т.е. Symbol не может быть ключом WeakMap).
// Почему WeakMap?

// Опытный JavaScript разработчик заметит, что map API можно реализовать на JavaScript c помощью двух массивов (один для ключей, второй для значений) и четырёх общих API методов. Установка элементов в этот map должна будет одновременно запушить ключи и значения. В результате индексы ключа и значения будут корректными. Получение значений с map потребует итерирование ключей, чтобы найти совпадение, а затем использование индекса этого соответствия для извлечения соответствующего значения из массива значений.

// У такой реализации было бы два главных неудобства. Первым является O(n) поиск (где n — количество ключей в map), так как обе операции требуют итерирование списка ключей для нахождения совпадения. Вторым — проблема утечки памяти. В словарях, написанных вручную, массив с ключами будет хранить ссылки на объекты-ключи, не давая им быть помеченными сборщиком мусора. В нативных WeakMap, ссылки на объекты-ключи хранятся «слабо», что означает то, что они не предотвратят сборку мусора в том случае, если других ссылок на объект не будет.

// WeakMaps имеют “weak” («слабые») обращения к ключам объекта, а следовательно непрепятствие сборщику мусора, когда мы больше не имеем объекта-ключа. WeakMaps могут быть особенно полезными конструкциями при сопоставлении ключей с информацией о ключе, который ценен, только есл

// const wm1 = new WeakMap(); // создаем экземпляр
//     wm2 = new WeakMap();
//     wm3 = new WeakMap();

// //заносим значения в формате коллекция пара ключ значение

// wm1.set({}, [1,3,4,5,6])

// wm2.set (function(){}, "sasd")

// значениями могут быть что угоднго, напрмер объекты, но ключ не может быть строкой

//________________________________WeakSet________________________________________

// Объект WeakSet - коллекция, элементами которой могут быть только объекты.

// var ws = new WeakSet();
// var obj = {};
// var foo = {};

// ws.add(window);
// ws.add(obj);

// ws.has(window); // true
// ws.has(foo);    // false, foo не добавлен в WeakSet

// ws.delete(window); // удаляет window из WeakSet
// ws.has(window);    // false, window был удалён

//________________________________LERN JS ________________________________________

// let wakeup = new WeakMap()
// let obj = {}
// wakeup.set(obj, 'ok')
// alert(wakeup.has('ok'))

// let user = {
//   name: "Jhon",
// };
// let weakMap = new WeakMap();
// weakMap.set(user, "...");
// user = null; // удалена ссылка , объект удален из памяти
// console.log(weakMap.has(user));

// let visitCountMap = new WeakMap();

// let user = {
//   name: "Vladimir",
// };

// function visitor(user) {
//   let count = visitCountMap.get(user) || 0;
//   visitCountMap.set(user, count + 1);
// }
// visitor(user)
// console.log(visitCountMap.has(user));




//_______________________________ПРИМЕР ДЛЯ КЕШИРОВАНИЯ ________________________
// let cache = new WeakMap()

// //вычисляем и запоминаем результат

// function procrss(obj){
//     if(!cache.has(obj)){
//         let result = /*Вычислям результат */  obj

//         caches.set(obj, result)
//     }

//     return cache.get(obj)
// }


// //main.js

// let obj = {}

// let result1 = procrss(obj)
// let result2 = procrss(obj)

// // ...позже, когда объект больше не нужен:

// obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются





// // нельзя использовать строку в качестве ключа
// weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект

// Сравните это поведение с поведением обычного Map, пример которого был приведён ранее. Теперь john существует только как ключ в WeakMap и может быть удалён оттуда автоматически.

// WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.

// В WeakMap присутствуют только следующие методы:

//     weakMap.get(key)
//     weakMap.set(key, value)
//     weakMap.delete(key)

// В основном, WeakMap используется в качестве дополнительного хранилища данных.

// Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то WeakMap – как раз то, что нужно.

// Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.

// weakMap.set(john, "секретные документы");
// // если john умрёт, "секретные документы" будут автоматиче

// let visitedSet = new WeakSet();

// let john = { name: "John" };
// let pete = { name: "Pete" };
// let mary = { name: "Mary" };

// visitedSet.add(john); // John заходил к нам
// visitedSet.add(pete); // потом Pete
// visitedSet.add(john); // John снова

// // visitedSet сейчас содержит двух пользователей

// // проверим, заходил ли John?
// alert(visitedSet.has(john)); // true

// // проверим, заходила ли Mary?
// alert(visitedSet.has(mary)); // false

// john = null;

// let messages = [
//     {text: "Hello", from: "John"},
//     {text: "How goes?", from: "John"},
//     {text: "See you soon", from: "Alice"}
//   ];

//   let readingMessage = new WeakSet()
//   readingMessage.add(messages[0])
//   readingMessage.add(messages[1])

//   alert('read message 0 ' + readingMessage.has(messages[0]))

//   WeakSet позволяет хранить набор сообщений и легко проверять наличие сообщения в нём.

// Он очищается автоматически. Минус в том, что мы не можем перебрать его содержимое, не можем получить «все прочитанные сообщения» напрямую. Но мы можем сделать это, перебирая все сообщения и фильтруя те, которые находятся в WeakSet.
