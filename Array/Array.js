// Объекты позволяют хранить данные со строковыми ключами. Это замечательно.

// Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й, 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.

// В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов. Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.

// Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.



//  let users = ['Vladimir', 'Max', 'Genadii']
// // alert(users[users.length - 1])   //вывести последний элемент массива


// // К счастью, есть более короткий синтаксис: fruits.at (-1):
// alert (users.at(-2)) //max

// _________________________Методы pop/push, shift/unshift_______________

// Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:

// push добавляет элемент в конец.
// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.


//_______________________Методы, работающие с концом массива:_____________

// pop
// Удаляет последний элемент из массива и возвращает его:

// let fructs = ['Груша', 'Яблоко', 'Банан']
// alert(fructs.pop()) 
// alert(fructs) // Груша, Яблоко

// push
// Добавляет элемент в конец массива:

// let fructs = ['Яблоко', 'Апелcин']
// fructs.push('Груша')
// alert(fructs)

//___________________Методы, работающие с началом массива:______________

// shift
// Удаляет из массива первый элемент и возвращает его:

// let fructs = ['Яблоко', 'Груша', 'Апельсин']
// alert(fructs.shift()) // удаляем Яблоко и выводим его
// alert( fruits ); // Апельсин, Груша

// unshift
// Добавляет элемент в начало массива:

// let fructs = ['Яблоко', 'Груша', 'Апельсин']
// fructs.unshift('Жопа')
// console.log(fructs);

//_____________________Внутреннее устройство массива___________________
// Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] – это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.

//_____________________Эффективность__________________________________

// Эффективность заключается в том, что при операциях unshift и shift происходит больше нагрузки, выделяеься больше памяти. Эти опирации произойдут за 3 действия. 
// 1) удалить элемент
// 2) сдвинуть, заново пронумеровать
// 3) обновить свойство length

// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.

// // Действия при операции pop:

// Метод pop не требует перемещения, потому что остальные элементы остаются с теми же индексами. Именно поэтому он выполняется очень быстро.

// ______________________Перебор элементов________________________________


// let arr = ['Яблоко','Гиена','Банан']

// for(let i = 0; i < arr.length; i++){
//     console.log(arr[i]);
// }

// for (let i of arr){
//     console.log(i);     //Тоже самое что и выше
// }

//_______________________Немного о «length»______________________________
// let fructs = []
// fructs[2] = 'apple'
// console.log(fructs);

// let arr = [1,2,3,4,5,6,7]

// arr.length = 2                   //Уменишили массив, потом                       возвратили            длину, но числа не возвратилтились


// console.log(arr);
// arr.length = 6;
// console.log(arr[4]) = unfefined

//_______________________new Array(number)______________________________

// Существует ещё один вариант синтаксиса для создания массива:

// let arr = new Array("Яблоко", "Груша", "и тд");

// Он редко применяется, так как квадратные скобки [] короче. Кроме того, у него есть хитрая особенность.

// Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.

// Давайте посмотрим, как можно оказать себе медвежью услугу:

// let arr = new Array (2)
// alert([0])
// alert(arr.length)

//____________________Многомерные массивы_______________________________

// let matrix = [
//     [1,2,3],
//     [4,5,6],
//     [7,8,9]
// ]
// alert(matrix[2][2]) // 9

//________________________toString__________________________________________

// let arr = [1,2,3]
// alert(arr)
// alert(String(arr) === '1,2,3')

//_____________________________ЗАДАЧИ_____________________________________

// let styles = ['Джаз','Блюз']
// alert(styles.push('Рок-н-ролл'))
// alert[Math.floor(styles.length-1)/2] = 'Классика'
// alert(styles.shift())
// alert(styles.unshift())


// Вызов arr[2]() синтаксически – старый добрый obj[method](), в роли obj – arr, а в роли method – 2.

// Итак, у нас есть вызов функции arr[2] как метода объекта. Соответственно, он получает в качестве this объект arr и выводит массив:

// let arr = ["a", "b"];

// arr.push(function() {
//   alert( this );
// })

// arr[2](); // a,b,function(){...}







// __________________________________________________________________________
// Напишите функцию sumInput(), которая:

//     Просит пользователя ввести значения, используя prompt и сохраняет их в массив.
//     Заканчивает запрашивать значения, когда пользователь введёт не числовое значение, пустую строку или нажмёт «Отмена».
//     Подсчитывает и возвращает сумму элементов массива.

// P.S. Ноль 0 – считается числом, не останавливайте ввод значений при вводе «0».



// function sumInput(){
//     let numbers = []
//     while(true){
//         let number = +prompt('Enter a number', 0)
//         if (number === '' || number === null ||!isFinite(number)) break;
//         numbers.push(number)
//     }
//   let sum = 0;
//   for(let numb of numbers ){
//     sum+=numb;
//   }
//   return numbers;
// }
// alert(sumInput())


// __________________________________________________________________________
// На входе массив чисел, например: arr = [1, -2, 3, 4, -9, 6].

// Задача: найти непрерывный подмассив в arr, сумма элементов в котором максимальна.

// Функция getMaxSubSum(arr) должна возвращать эту сумму.

// Например:

// getMaxSubSum([-1, 2, 3, -9]) == 5 (сумма выделенных элементов)
// getMaxSubSum([2, -1, 2, 3, -9]) == 6
// getMaxSubSum([-1, 2, 3, -9, 11]) == 11
// getMaxSubSum([-2, -1, 1, 2]) == 3
// getMaxSubSum([100, -9, 2, -3, 5]) == 100
// getMaxSubSum([1, 2, 3]) == 6 (берём все)


// function getMaxSubSum(arr) {
//     let maxSum = 0;
//     let partialSum = 0;

//     for(let item of arr){
//         partialSum += item;
//         // console.log(partialSum);//1
//         // console.log(maxSum)
//         maxSum = Math.max(maxSum, partialSum)
//         // console.log(partialSum);//1
//         // console.log(maxSum)
//         if(partialSum < 0) partialSum = 0;
//         // console.log(partialSum);//1
//         // console.log(maxSum)


//     }
//     return maxSum
// }
// alert(getMaxSubSum([-1, 2, 3, -9]))